# DP

### 53. Maximum Subarray

#### [解法一](53-Maximum-Subarray.java)：动态规划

状态定义：```dp[i]``` 表示从位于0到i - 1的数字构成的子序列能有的最大子序列和是多少。

初始化：```dp[0] = nums[0];```

状态转移方程式：因为所有的数字都是非负数，所以只有两种可能性，一种是直接把前面的最大序列和加上当前的数字，另一种是只取当前数字（因为当前数字比之前的和加上当前数字要大）

### 62. Unique Paths

#### [解法一](62-Unique-Paths/62-Unique-Paths.cpp)：排列组合插板法

机器人一共需要走 ```m + n - 2``` 步，其中 ```n - 1``` 步是向下走，所以从这其中选取 ```n - 1``` 步即可。公式得到 C(m + n - 2, n - 1)。注意这里用的是组合不是排列，因为我们就是选取，这里并没有办法做排列，因为走路是连续的。

为了防止溢出，每一层循环都一边做乘法一边做除法。

#### [解法二](62-Unique-Paths/62-Unique-Paths-DP.java)：动态规划

状态定义：```dp[i][j]``` 表示到达第i行第j列这个格子一共有多少种不同的走法

初始化：到第一行中任意一个点都只有一种走法，到第一列中任意一个点都只有一种走法，第一行和第一列初始化为1。

状态转移方程式：到达某个点可以有两个选择，一个是从上面走一个是从左边走，所以把这两个格子的不同走法相加即可。

```dp[i][j] = dp[i - 1][j] + dp[i][j - 1];```

### 70. Climbing Stairs

#### [解法一](70-Climbing-Stairs.java)：动态规划

状态定义： ```dp[i]``` 表示当有i个台阶时，有多少种爬楼梯的方法。i >= 1

初始化：```dp[1] = 1; dp[2] = 2```

状态转移方程式：到达一个台阶的方法有两种，一种是从i - 1级走一级上来，一种是从i - 2走两级上来，所以把这两个状态的情况数量相加即可。

```dp[i] = dp[i - 1] + dp[i - 2]```

空间优化：因为只需要前两个点的状况，所以可以定义两个变量存储前两个点，不需要整个数组。最后根据奇偶性判断输出哪个。

### 72. Edit Distance

#### [解法一](72-Edit-Distance.java)：动态规划

状态定义：我们求解把第一个单词（左侧）换成第二个单词（上面—），```dp[i][j]```表示最少需要多少个操作把第一个单词的0-i子串换成第二个单词的0-j子串。

初始化：单看两个单词，第一行和第一列需要多少操作并不能直接看出来，但是如果我们定义```dp[0][j]```和```dp[i][0]```为某个子串和空串的编辑距离，我们可以直接得到 ```dp[0][j] = j``` 和 ```dp[i][0] = i``` ，由此可以初始化第一行和第一列。

状态转移方程式：一共有三种方法完成当前编辑

1. 如果已经完成了 ```word1[0 ~ i - 1]``` 到 ```word2[0 ~ j - 1]``` 的编辑，可以看 ```word1[i]``` 和 ```word2[j]``` 是否相等，如果相等则编辑距离就是 ```dp[i - 1][j - 1]``` ，否则在此基础上加一
2. 从左侧往右侧加一，我们知道了 ```word1[0 ~ i - 1]``` 到 ```word2[0 ~ j]``` 的编辑距离，因此还需补充一个字母，编辑距离加一
3. 从上面往下面加一，我们知道了 ```word1[0 ~ i]``` 到 ```word2[0 ~ j - 1]``` 的编辑距离，因此还需删除一个字母，编辑距离加一

```Java
int t = 1;
if (word1.charAt(i - 1) == word2.charAt(j - 1))
    t = 0;
int temp = Math.min(dp[i - 1][j - 1] + t, dp[i - 1][j] + 1);
temp = Math.min(temp, dp[i][j - 1] + 1);
dp[i][j] = temp;
```

---

### 983. Minimum Cost For Tickets

#### 解法一：动态规划

状态定义：```dp[i]``` 即为第i天最少需要多少钱能完成从第0天到第i天的行程

初始化：```dp[0] = 0```

状态转移方程式：如果当天没有行程，则需要的价格和昨天一样，否则一共有三种方式完成当天的行程：
1. 买一张单日票 ```dp[i - 1] + cost[0]```
2. 6天前买了一张7日票，现在使用这张票，加上7天前的花费 ```dp[i - 7] + cost[1]```
3. 29天前买了一张30日票，现在使用这张票，加上30天前的花费 ```dp[i - 30] + cost[2]```
注意：如果当前日期不满7天或者30天，则假设第0天买了多日票

```Java
if (travels[i])
{
    dp[i] = Math.min(dp[i - 1] + costs[0], dp[Math.max(0, i - 7)] + costs[1]);
    dp[i] = Math.min(dp[i], dp[Math.max(0, i - 30)] + costs[2]);
}  
else
    dp[i] = dp[i - 1];
```