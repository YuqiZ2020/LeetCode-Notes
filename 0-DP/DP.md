# DP

### 70. Climbing Stairs

#### [解法一](70-Climbing-Stairs.java)：动态规划

状态定义： ```dp[i]``` 表示当有i个台阶时，有多少种爬楼梯的方法。i >= 1

初始化：```dp[1] = 1; dp[2] = 2```

状态转移方程式：到达一个台阶的方法有两种，一种是从i - 1级走一级上来，一种是从i - 2走两级上来，所以把这两个状态的情况数量相加即可。

```dp[i] = dp[i - 1] + dp[i - 2]```

空间优化：因为只需要前两个点的状况，所以可以定义两个变量存储前两个点，不需要整个数组。最后根据奇偶性判断输出哪个。

### 72. Edit Distance

#### [解法一](72-Edit-Distance.java)：动态规划

状态定义：我们求解把第一个单词（左侧）换成第二个单词（上面—），```dp[i][j]```表示最少需要多少个操作把第一个单词的0-i子串换成第二个单词的0-j子串。

初始化：单看两个单词，第一行和第一列需要多少操作并不能直接看出来，但是如果我们定义```dp[0][j]```和```dp[i][0]```为某个子串和空串的编辑距离，我们可以直接得到 ```dp[0][j] = j``` 和 ```dp[i][0] = i``` ，由此可以初始化第一行和第一列。

状态转移方程式：一共有三种方法完成当前编辑

1. 如果已经完成了 ```word1[0 ~ i - 1]``` 到 ```word2[0 ~ j - 1]``` 的编辑，可以看 ```word1[i]``` 和 ```word2[j]``` 是否相等，如果相等则编辑距离就是 ```dp[i - 1][j - 1]``` ，否则在此基础上加一
2. 从左侧往右侧加一，我们知道了 ```word1[0 ~ i - 1]``` 到 ```word2[0 ~ j]``` 的编辑距离，因此还需补充一个字母，编辑距离加一
3. 从上面往下面加一，我们知道了 ```word1[0 ~ i]``` 到 ```word2[0 ~ j - 1]``` 的编辑距离，因此还需删除一个字母，编辑距离加一

```Java
int t = 1;
if (word1.charAt(i - 1) == word2.charAt(j - 1))
    t = 0;
int temp = Math.min(dp[i - 1][j - 1] + t, dp[i - 1][j] + 1);
temp = Math.min(temp, dp[i][j - 1] + 1);
dp[i][j] = temp;
```

---